---
marp: true
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会#-->

# SOLID #2 開放閉鎖の原則
_Open Closed Principle_

> ## ソフトウェアの構成要素は拡張に対して開いていて、修正に対して閉じていなければならない$^1$

>>> バートランド・メイヤー『オブジェクト指向入門』1988年 アスキー刊

---

## ・・・ん？ 🤔

わかりやすく言い換えると、既存の処理を修正せずに各要素の振る舞いを拡張できる状態のこと

* **拡張に対して開いている:** 機能追加がしやすいこと
* **修正に対して閉じている:** 機能追加時に既存コードの書き換えが不要なこと

### → OCP = アーキテクチャが満たす根本的なゴール

<!-- 拡張と修正の言葉の言葉の意味を整理しておく。
1. 拡張:
  * 新しい機能や振る舞いを追加すること。
  * 既存のコードを変更せずに新しいモジュールやクラスを追加することで行われる。
2. 修正:
  * 既存のコードの変更。
  * バグの修正や既存の機能の変更など、すでに存在するコードの内容を直接変更する行為。

OCPの目的は、新しい機能や変更が必要なとき、既存のコードを変更するのではなく、新しいコードを追加することでその要件を満たすことができるような設計を心がけること
https://zenn.dev/naas/scraps/41ed1c120aff53
-->

<!-- ちょっとした拡張のために大量の書き換えが必要になるようなら、そのプロジェクトは大失敗への道を進んでいることになる -->

<!-- もう一度繰り返しておくと、既存コードが修正不要で機能拡張できることがOCP -->

---

## OCP実現例

* プリンタ/スキャナドライバをOSに追加する仕組み
* ソフトウェアのプラグイン機構
* ゲームのMOD

どれも既存の処理・コードを変更することなく機能追加できている

<!-- 考えてみるとすごい状態。OS,ソフトウェア,ゲームソフト本体のコードを一切変更していないのに、これまでと同じ機能が同じように動作し、新しい機能も問題なく動いている。これがOCPが実現する世界。 -->
<!-- 自分たちの作るものもこんな風にできたら良いと思いませんか？今まで作ったものに手を触れずに、安心して新しい機能を追加できる。
OSみたいな大きなプログラムだけがメリットを享受するわけではない。数理最適化の処理においても「この部分だけを取り替えてみたい」という試行錯誤が簡単にできるようになる -->
<!-- ちょっとOCPに興味が湧いてきましたよね -->

<!-- ただ、OCPはSOLIDの順番でこそ２番めに出てきているけれど、SOLID全般で目指すゴールの状態でもあるので、実現に必要なテクニックにはO以外の全部(S/L/I/D)すべての考え方が必要になる。なので今日は全体像を掴むための説明と、その説明理解に必要な概念を紹介します -->

---

## 「OCP」が指すものは２種類ある

歴史的に２つの意味合いを持っている

1. 1988年にバートランド・メイヤーが提唱したOCP
2. 1996年頃にロバート・C・マーチン(Bobおじさん)らが提唱したOCP

<!-- OCPには歴史的に２つあるので、それを紐解きつつ具体例を示していきます -->

---

## 1.バートランド・メイヤー版OCP

OCPの原点。オブジェクトのクラス構造として拡張性を取り入れることが主点。

* **開放されたモジュール**＝拡張可能なモジュール
* **閉鎖されたモジュール**＝内部の実装を知らなくても、仕様に従い安定して使えるモジュール

→ とても乱暴に言うと **「クラスやモジュールでポリモーフィズムを実現しましょう」** ということ

![center w:500pt](assets/02-ocp_mayer.png)

>>> 1988年のバートランド・メイヤー著書『Object Oriented Software Construction』で提唱

<!-- 親クラスで安定した仕様をしっかり定義しておき、それを継承する各サブクラスで実装の修正または拡張を行なっていくことで、具体的な処理はサブクラスで実装すれば、使用者にとっては親クラスを使っているつもりで処理を切り替えることができる。使用者は実体につられてソースコードを変更しなくても良い -->
<!--
 つまりメイヤーの原則では、具象メソッド（シグネチャ＋コード）の実装継承（implementation inheritance）と、サブクラスを追加定義していく深い継承が基本になる。
 親クラスは単なるインターフェイスを定義するだけでなく実際の処理を持っていても良く、また子だけでなく孫クラスや曾孫クラスになることを想定している -->

---

## 2.ロバート・C・マーチン版OCP

メイヤーのOCPをより高い視点で適用。モジュールをプログラム実行時に差し替えることを想定$^1$

* プリンタ/スキャナドライバをOSに追加する仕組み
* ソフトウェアのプラグイン機構
* ゲームのMOD

モジュールとして仕様に従ったものを作れば **プログラムの再ビルドすら不要**

![center w:500pt](assets/02-ocp_unclebob.png)

>>> 1996年論文『The Open-Closed Principle』

<!-- クラス構造の視点でいうと、マーチンの原則では、実装を持たない抽象メソッドだけ定義したインターフェイスクラスを定義し、それを界面継承（interface inheritance）が基本になる。継承関係はインターフェースの実装のみに留めて、実装の継承は抑えることがメイヤー版との違い。 -->

<!-- 一般的にOCPでググると出てくるのは、メイヤーのようにコードレベルでの話をしているものが多い。ただし最近は親クラスといっても実装を持たないスタイルが主流になっているので、その点ではボブおじさんのインターフェイスのみ用意してそれを継承するという内容に近い -->

<!-- ちなみに昔はたくさんあったTwitterクライアントも広義のボブおじさん版OCPの適用例と言える。どのクライアントアプリもTwitterのAPIというインターフェイスを守っていれば同じようにタイムラインを見たり投稿できた。このときにTwitterサービスそのものを修正する必要はない。 -->

---


複数のアルゴリズムと実行する処理とは別にする

* GoFデザインパターンのいくつか(State Pattern)