---
marp: true
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会#-->

# SOLID #2 開放閉鎖の原則
_Open Closed Principle_

> ## ソフトウェアの構成要素は拡張に対して開いていて、修正に対して閉じていなければならない$^1$

>>> バートランド・メイヤー『オブジェクト指向入門』1988年 アスキー刊

---

## ・・・ん？ 🤔

わかりやすく言い換えると、既存の処理を修正せずに各要素の振る舞いを拡張できる状態のこと

* **拡張に対して開いている:** 機能追加がしやすいこと
* **修正に対して閉じている:** 機能追加時に既存コードの書き換えが不要なこと

### → OCP = アーキテクチャが満たす根本的なゴール

<!-- 拡張と修正の言葉の言葉の意味を整理しておく。
1. 拡張:
  * 新しい機能や振る舞いを追加すること。
  * 既存のコードを変更せずに新しいモジュールやクラスを追加することで行われる。
2. 修正:
  * 既存のコードの変更。
  * バグの修正や既存の機能の変更など、すでに存在するコードの内容を直接変更する行為。

OCPの目的は、新しい機能や変更が必要なとき、既存のコードを変更するのではなく、新しいコードを追加することでその要件を満たすことができるような設計を心がけること
https://zenn.dev/naas/scraps/41ed1c120aff53
-->

<!-- ちょっとした拡張のために大量の書き換えが必要になるようなら、そのプロジェクトは大失敗への道を進んでいることになる -->

---

## OCP実現例

* プリンタ/スキャナドライバをOSに追加する仕組み
* ソフトウェアのプラグイン機構
* ゲームのMOD

どれも既存の処理・コードを変更することなく機能追加できている

<!-- 考えてみるとすごい状態。OS,ソフトウェア,ゲームソフト本体のコードを一切変更していないのに、これまでと同じ機能が同じように動作し、新しい機能も問題なく動いている。これがOCPが実現する世界。 -->
<!-- 自分たちの作るものもこんな風にできたら良いと思いませんか？今まで作ったものに手を触れずに、安心して新しい機能を追加できる。
OSみたいな大きなプログラムだけがメリットを享受するわけではない。数理最適化の処理においても「この部分だけを取り替えてみたい」という試行錯誤が簡単にできるようになる -->
<!-- ちょっとOCPに興味が湧いてきましたよね -->

<!-- ただ、OCPはSOLIDの順番でこそ２番めに出てきているけれど、SOLID全般で目指すゴールの状態でもあるので、実現に必要なテクニックにはO以外の全部(S/L/I/D)すべての考え方が必要になる。なので今日は全体像を掴むための説明と、その説明理解に必要な概念を紹介します -->

---

## 「OCP」が指すものは２種類ある

歴史的に２つの意味合いを持っている

1. 1988年にバートランド・メイヤーが提唱したOCP
2. 1996年頃にロバート・C・マーチン(Bobおじさん)らが提唱したOCP

<!-- OCPには歴史的に２つあるので、それを紐解きつつ具体例を示していきます -->

---

## 1.バートランド・メイヤー版OCP

OCPの原点。オブジェクトのクラス構造として拡張性を取り入れることが主点。

* 開放されたモジュール＝拡張可能なモジュール
* 閉鎖されたモジュール＝内部の実装を知らなくても、仕様に従い安定して使えるモジュール

→ 端的に言うと「ポリモーフィズムを実現しましょう」ということ

親クラスで不変の仕様を定義をして、それを継承する各子孫クラスで実装の修正または拡張を行なっていくべきとした。親クラスの変数には、親クラスまたは各子孫クラスのインスタンスが代入される。クライアントはその親クラス変数を恒久的に使えて、その変数に子孫インスタンスが代入されていても支障をきたさない[5]。

メイヤーの原則では、具象メソッド（シグネチャ＋コード）の実装継承（implementation inheritance）と、子クラスを追加定義していく深い継承が基本になる。

---

## 2.ロバート・C・マーチン版OCP

インターフェースの実行時サブタイピングを重視するように意味が変わっていった。ロバート・C・マーチンの1996年論文『The Open-Closed Principle』などが、これをアプローチしている。

抽象メソッドだけで構成される不変のインターフェースを定義して、それをコード実装するための兄弟クラスを様々に定義し、ランタイムでインターフェース変数への各兄弟インスタンスの代入と交換を行って、実行時ポリモーフィックするべきとした。

マーチンの原則では、抽象メソッド（シグネチャだけ）の界面継承（interface inheritance）が基本になる。継承関係はインターフェースの実装に留めて、クラスの継承は抑えることが基本になる。

---


複数のアルゴリズムと実行する処理とは別にする

* GoFデザインパターンのいくつか(State Pattern)