---
marp: true
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会#-->

# SOLID #2 開放閉鎖の原則
_Open Closed Principle_

> ## ソフトウェアの構成要素は拡張に対して開いていて、修正に対して閉じていなければならない$^1$

>>> バートランド・メイヤー『オブジェクト指向入門』1988年 アスキー刊

---

## ・・・ん？ 🤔

わかりやすく言い換えると、既存の処理を修正せずに各要素の振る舞いを拡張できる状態のこと

* **拡張に対して開いている:** 機能追加がしやすいこと
* **修正に対して閉じている:** 機能追加時に既存コードの書き換えが不要なこと

### → OCP = アーキテクチャが満たす根本的なゴール

<!-- ちょっとした拡張のために大量の書き換えが必要になるようなら、そのプロジェクトは大失敗への道を進んでいることになる -->

---

## OCP実現例

* プリンタ/スキャナドライバをOSに追加する仕組み
* ソフトウェアのプラグイン機構
* ゲームのMOD

どれも既存の処理・コードを変更することなく機能追加できている

<!-- 考えてみるとすごい状態。OS,ソフトウェア,ゲームソフト本体のコードを一切変更していないのに、これまでと同じ機能が同じように動作し、新しい機能も問題なく動いている。これがOCPが実現する世界。 -->
<!-- 自分たちの作るものもこんな風にできたら良いと思いませんか？今まで作ったものに手を触れずに、安心して新しい機能を追加できる。
OSみたいな
大きなプログラムだけがメリットを享受するわけではない。数理最適化の処理においても「この部分だけを取り替えてみたい」という試行錯誤が簡単にできるようになる -->
<!-- ちょっとOCPに興味が湧いてきましたよね -->

---

## OCPが指すものは２種類ある

歴史的に２つの意味合いを持っている

1. 1988年にバートランド・メイヤーが提唱したOCP
2. 1996年頃にロバート・C・マーチン(Bobおじさん)らが提唱したOCP

<!-- OCPには歴史的に２つあるので、それを紐解きつつ具体例を示していきます -->

---

## 1.バートランド・メイヤー版OCP

OCPの原点。

* 開放されたモジュール＝拡張可能なモジュール
* 閉鎖されたモジュール＝内部の実装を知らなくても、仕様に従い安定して使えるモジュール

メイヤーは、親クラスで不変の仕様を定義をして、それを継承する各子孫クラスで実装の修正または拡張を行なっていくべきとした。親クラスの変数には、親クラスまたは各子孫クラスのインスタンスが代入される。クライアントはその親クラス変数を恒久的に使えて、その変数に子孫インスタンスが代入されていても支障をきたさない[5]。

メイヤーの原則では、具象メソッド（シグネチャ＋コード）の実装継承（implementation inheritance）と、子クラスを追加定義していく深い継承が基本になる。

---

## 2.ロバート・C・マーチン版OCP

インターフェースの実行時サブタイピングを重視するように意味が変わっていった。ロバート・C・マーチン（英語版）の1996年論文『The Open-Closed Principle』などが、これをアプローチしている。

抽象メソッドだけで構成される不変のインターフェースを定義して、それをコード実装するための兄弟クラスを様々に定義し、ランタイムでインターフェース変数への各兄弟インスタンスの代入と交換を行って、実行時ポリモーフィックするべきとした。

マーチンの原則では、抽象メソッド（シグネチャだけ）の界面継承（interface inheritance）が基本になる。継承関係はインターフェースの実装に留めて、クラスの継承は抑えることが基本になる。

---


複数のアルゴリズムと実行する処理とは別にする

* GoFデザインパターンのいくつか(State Pattern)
