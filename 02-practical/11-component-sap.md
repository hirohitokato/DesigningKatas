---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

### コンポーネントの原則 #6

# 安定度・抽象度等価の原則(SAP)
_Stable Abstractions Principle_

---
## タネ本

### 『クリーンアーキテクチャ<br>　 ― 達人に学ぶソフトウェアの構造と設計』
* Robert C. Martin(著), 角征典, 髙木正弘(訳)
* アスキードワンゴ刊
![bg right:30% 90%](assets/07-cleanarchitecture.jpg)

>>> 他の参考リンク: [SOLIDとパッケージ設計の原則とクリーンアーキテクチャとの関係性](https://zenn.dev/katzumi/scraps/7a4acc51793977)

---

## 安定度・抽象度等価の原則(SAP)

コンポーネントの抽象度 == コンポーネントの安定度

変更がしづらいコンポーネントは抽象的であるべきで、変更がしやすいコンポーネントは具体的であるべき

⇒ コンポーネントの変更や再利用の効率や品質を向上できる

---

## 安定度と抽象度

* **安定度**: 他からどれくらい依存されているか
    * 変更することの影響の大きさ
    * 安定度が高い = 多くのコンポーネントに依存されている
    * 不安定さ _I(Instability)_ = fan-out数 ÷ (fan-in数 + fan-out数)
* **抽象度**: 具体的な技術要素からどれだけ離れているか
    * 具体的な技術要素 = 保存先(ファイル,DB)/UIフレームワークの種類
    * 抽象度が高い = 具体的な実装がなく作成システムや概念,本質に注目している
        * 文字列・日付操作/ドメインデータ/コアロジック/アルゴリズム/etc.

⇒ 安定度の高いコンポーネントは抽象度も高くあるべき
　→ 具体的な実装を持つコンポーネントが他からの依存を避けるべき

---

## 逆だったらどうなる？（原則に違反している世界）

* **安定したコンポーネントが具体的**
    * 依存している他コンポーネントが具体的な実装に依存する
    * ⇒ 変更によって依存しているコンポーネントも変更しなければならない
    * ⇒ 変更の伝播や再利用の妨げになる
* **不安定なコンポーネントが抽象的**
    * コンポーネントの実装を隠蔽することになる
    * ⇒ コンポーネントの内部構造や動作が理解困難に
    * ⇒ テストやデバッグの困難さにつながる

---

## 違反しているときの改善方法

* 変更がしづらいコンポーネントは抽象的なインターフェイスやクラスを提供し、具体的な実装やデータ構造を隠蔽する
    * 例えば、コンポーネントXはビジネスロジックを表すインターフェイスやクラスを提供し、その実装やデータ構造は別のコンポーネントに移動させることができる。
    * これにより、ビジネスロジックに依存する他のコンポーネントは抽象的なインターフェイスやクラスに依存するようになる。
* 変更がしやすいコンポーネントは具体的な実装やデータ構造を公開し、抽象的なインターフェイスやクラスを減らす
    * 例えば、コンポーネントYはデータベースアクセスの方法や仕様を明確に示し、抽象化したインターフェイスやクラスは別のコンポーネントに移動させることができる。
    * これにより、データベースアクセスのパフォーマンスやエラー処理を確認することが容易になる。