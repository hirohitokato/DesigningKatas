---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

### コンポーネントの原則 #6

# 安定度・抽象度等価の原則(SAP)
_Stable Abstractions Principle_

---
## タネ本

### 『クリーンアーキテクチャ<br>　 ― 達人に学ぶソフトウェアの構造と設計』
* Robert C. Martin(著), 角征典, 髙木正弘(訳)
* アスキードワンゴ刊
![bg right:30% 90%](assets/07-cleanarchitecture.jpg)

---

## 安定度・抽象度等価の原則(SAP)

コンポーネントの抽象度 == コンポーネントの安定度

変更がしづらいコンポーネントは抽象的であるべきで、変更がしやすいコンポーネントは具体的であるべき

⇒ コンポーネントの変更や再利用の効率や品質を向上できる

---

## 安定度と抽象度

* **安定度**: 他からどれくらい依存されているか
    * 変更することの影響の大きさ
    * 安定度が高い = 多くのコンポーネントに依存されている
    * 不安定さ _I(Instability)_ = fan-out数 ÷ (fan-in数 + fan-out数)
* **抽象度**: 具体的な技術要素からどれだけ離れているか
    * 具体的な技術要素 = 保存先(ファイル,DB)/UIフレームワークの種類
    * 抽象度が高い = 具体的な実装がなく作成システムや概念,本質に注目している
        * 文字列・日付操作/ドメインデータ/コアロジック/アルゴリズム/etc.

⇒ 安定度の高いコンポーネントは抽象度も高くあるべき
　→ 具体的な実装を持つコンポーネントが他からの依存を避けるべき

---

## 逆だったらどうなる（原則に違反していると）

* 変更がしづらいコンポーネントが具体的であると、そのコンポーネントに依存する他のコンポーネントも具体的な実装に依存することになる。これは、変更がしづらいコンポーネントに変更があったときに、依存するコンポーネントも影響を受けて変更しなければならなくなることを意味する。これは変更の伝播や再利用の妨げになる。
* 変更がしやすいコンポーネントが抽象的であると、そのコンポーネントの実装を隠蔽することになる。これは、変更がしやすいコンポーネントの内部構造や動作を理解することが困難になることを意味する。これはテストやデバッグの困難さにつながる。