---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

### コンポーネントの原則 #6

# 安定度・抽象度等価の原則(SAP)
_Stable Abstractions Principle_

---
## タネ本

### 『クリーンアーキテクチャ<br>　 ― 達人に学ぶソフトウェアの構造と設計』
* Robert C. Martin(著), 角征典, 髙木正弘(訳)
* アスキードワンゴ刊
![bg right:30% 90%](assets/07-cleanarchitecture.jpg)

>>> 他の参考リンク: [SOLIDとパッケージ設計の原則とクリーンアーキテクチャとの関係性](https://zenn.dev/katzumi/scraps/7a4acc51793977)

---

## 安定度・抽象度等価の原則(SAP)

コンポーネントの抽象度 == コンポーネントの安定度

変更がしづらいコンポーネントは抽象的であるべきで、変更がしやすいコンポーネントは具体的であるべき

⇒ コンポーネントの変更や再利用の効率や品質を向上できる

---

## 安定度と抽象度

* **安定度**: 他からどれくらい依存されているか。変更がどれだけ影響を与えるか
    * <b>安定度が高い</b> = 多くのコンポーネントが依存している
    * <b>不安定さ</b> **_I_**(_Instability_) = `fan-out数 ÷ (fan-in数 + fan-out数)`
* **抽象度**: 具体的な技術要素からどれだけ離れているか
    * <b>具体的な技術要素</b> = 保存先(ファイル,DB)/UIフレームワークの種類
    * <b>抽象度が高い</b> = 具体的実装がなく作成システムや概念,本質に注目している
        * 文字列・日付操作/ドメインデータ/コアロジック/アルゴリズム/etc.

⇒ 安定度の高いコンポーネントは抽象度も高くあるべき
　⇔ 具体的な実装を持つコンポーネントは他から依存されないようにすべき

---

## 逆だったらどうなる？（原則に違反している世界）

* <b>安定したコンポーネントが具体的になっている</b>
    * ⇒ 変更によって依存元コンポーネントも変更しなければならない
    * ⇒ 変更の伝播や再利用の妨げになる
* <b>不安定なコンポーネントが抽象的</b>
    * コンポーネントの実装を隠蔽することになる
    * ⇒ コンポーネントの内部構造や動作が理解困難に
    * ⇒ テストやデバッグの困難さにつながる

<!-- 
1. 具体的な実装にみんなが依存している。具体実装が変わった途端に大惨事

-->
---

## 違反しているときの改善方法

* 変更がしづらいコンポーネントの場合…
    * インターフェイスや抽象クラスを提供し、具体的な実装・データ構造を隠蔽
    * → ビジネスロジックへの直接依存からインターフェイスや抽象クラスへの間接依存
* 変更がしやすいコンポーネントの場合…
    * 具体的な実装やデータ構造を公開し、抽象的な型を減らす
    * → 通信パフォーマンスやエラー処理を確認することが容易に

<!-- 例えば、コンポーネントXはビジネスロジックを表すインターフェイスやクラスを提供し、その実装やデータ構造は別のコンポーネントに移動させることができる。
 -->