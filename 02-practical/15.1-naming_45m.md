---
marp: true
math: mathjax
theme: katas
title: "読みやすいコードの書き方 - 命名編"
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 読みやすいコードの書き方 - 命名編-->

# 読みやすいコードの作り方 - 命名

_Code Readability_

---

## タネ本

### 『読みやすいコードのガイドライン<br>　 持続可能なソフトウェア開発のために』
- 石川宗寿(著)
- 技術評論社 2022/11/4初版

> 見た目を美しく整えることや、流行りの<br>テクニックを取り入れることが「改善」だと<br>思い込んでいませんか？

![bg right:30% 90%](assets/12-book.jpg)

---

## 命名

1. **命名に使う文法**
2. 名前の示す内容
3. 単語の選択

---

## 命名の対象

- クラス(インターフェース、列挙型、構造体、プロトコル、トレイト、etc.)
- 変数(定数、プロパティ、フィールド、仮引数、ローカル変数、etc.)
- 関数(メソッド、手続き、サブルーチン、etc.)
- スコープ(パッケージ、モジュール、名前空間、etc.)
- リソース(ファイル、ディレクトリ、ID、etc.)

---

## どうあるべきか

- 正確であること
    - 名前の示す意味とその実態が一致していること
- 説明的であること
    - 名前を見ただけで何であるかが理解できること

---

## 前提: 英文法に近い形で命名する

<b>例「メッセージ表示用のテキストビューで発生したクリックイベントのリスナー」</b>
- **✕** `ListenerEventMessageClickViewText`
    - 「リスナーを対象とするイベントのメッセージ(?)を表示するクリックビュー(??)のテキスト？？」🤔
- **◯** `MessageTextViewClickEventListener`
    - (末尾から読みながら)イベントリスナーである<br> → クリックに関するイベントのようだ<br> → テキストビュー、しかもメッセージに関連しそうだ

**解釈が一意に定まる**ように命名する

---

## 前提: 品詞を使い分ける

<b>▶ 名詞/名詞句</b>  : 
- クラスやインターフェースなどの型名
    - `HashSet`,`ImageRenderer`, etc.
- 性質や状態を返す関数、新たに作られたオブジェクトを返す関数
    - `size()`, `length()`, `listOf()`, etc.

<b>▶ 命令文</b>
- 一般的な関数、手続き、メソッド
    - `add(…)`, `registerDescription(…)`, `getValue()`, etc.

### 例外も多いがまずはこの２つを覚える

---

## 名詞/名詞句の使い方 (型や変数の命名方法)

1. 名前を付ける対象を示す単語(最も重要な単語)を最後に置く
    - 例) ボタンの高さ:  **✕**`heightButton` →  **◯**`buttonHeight`
    - 修飾語句が長い場合は工夫する(が、例外として考える):
        - **✕**`portraitModeButtonHeight` →  **△**`buttonHeightInPortraitMode`
2. 解釈の幅を持たせない
    - 例) ユーザー数: **✕**`numUsers` <br>　→ **△**`numberOfUsers`, **△**`userNumber`, <br>　→ **◯**`userCount`, **◯**`userTotal`

- 性質や状態を返す関数の場合は仮引数まで含めて名詞句にすることを考える
    - `indexOf(element)`, `maxValueIn(array)`

---

## 命令文の使い方 (関数/メソッドの命名方法)

1. 動詞の原形を先頭に置いた関数名にする
    - ユーザーの動作を記録する: **✕**`userActionLog()` →  **◯**`logUserAction()`
2. 関数が引数を取る場合は仮引数の名前も含めて命令文を構成する(こともある)
    - 値をvalueと比較する: `compareTo(value)`
3. 性質や状態を返す関数には名詞(句)を使う
    - `size()`, `length()`, `maxValueIn(array)`
    - 名詞句を使わない場合は`get`/`query`/`obtain`などを先頭に置く
    - 副作用の有無や実行時間を意味に含める:<br> **✕**`getAverage()` → **◯**`calculateAverage()`

---

<b>▶ 形容詞/形容詞句、分詞</b>
- 性質や状態、処理される対象を示すクラスや変数
    - `Iterable`, `Decodable`, `PLAYING`, `FINISHED`, etc.
- 新たに作られたオブジェクトを返す関数
    - `sorted()`, `appending()`, etc.

<b>▶ 三人称単数形の動詞/助動詞、それによる疑問文</b>
- 真偽値を示す変数・関数
    - `contains(x)`, `shouldUpdate`, `isTextVisible`, `equalsTo(value)`, etc.

<b>▶ 前置詞を伴う副詞句</b>
- 形を変換する関数、コールバックに用いる引数
    - `toInt()`, `fromMemberId(x)`, `asSequence()`, `onFinished`, etc.

<!-- 真偽値を示す変数・関数のときに、途中でisとかが入るような文になっているのは冗長な場合があるし、直訳でダサいのでやめよう。
例えば「初期化処理が完了したか」でisを使わなければと「initializing_is_completed」としたりすることがあるが、これは「wasInitialized」でいい。 -->

---

## なぜ文法が無視されていくのか
`UserActionEvent`というイベントの基底クラスがあったとして…

```cpp
// ◯ あるべき姿
class ClickActionEvent: UserActionEvent { … }
class DragActionEvent: UserActionEvent { … }
class MouseOverActionEvent: UserActionEvent { … }
```
```cpp
// ✕ 宣言箇所での見た目の統一感を優先した姿
class UserActionEventClick: UserActionEvent { … }
class UserActionEventDrag: UserActionEvent { … }
class UserActionEventMouesOver: UserActionEvent { … }
```

**見た目の美しさや統一感・一貫性は可読性のための手段。**<br>理解しやすいかどうかを重視すること

---

## 命名に使う文法: まとめ

- 名前は正確で説明的であること
- 英文法にしたがい解釈しやすくすること
- 品詞を対象やその状況で使い分けること
- 見た目の美しさ　＜　読みやすさ

<!-- 
私の知っている範囲での回答をしますと、


1. 昔の開発環境(ツール, PC, etc.)は、長い名前を扱うのが難しかった
    1. メモリの問題で、コンパイラで文字数制限を設けたりしていた
    2. ソースコードのサイズにも注意しないといけなかった
    3. 長い名前にするとコンパイル時間も長くなる環境もあった
        - 文字列比較などで時間がかかる
    4. PC画面は多くて80x25行しか表示できなかったりするので、長い名前だとはみ出てしまう
        - 横スクロールもできないので折り返されて読みにくくなる
    5. エディタに補完機能もないので、長いと入力が大変
2. 組込OSのAPIはその時代に作られた標準や規格に準拠していることが多く、関数名や変数名が短いものが選ばれた
    1. しかも互換性至上なのでそれを維持し続けてきた
    2. 規格の新陳代謝もそれほど必要とされないので、今も多く残っている
3. ベテランプログラマは、難しいコードを自由に読み書きできることを若手へのマウントポイントにしがち(偏見)

あたりが重なって、省略語の多い状況になっています。
（3は冗談ですからね！組込もWebもアプリもみんな仲良くやっていきましょうね！！）
 -->

---

1. 命名に使う文法
2. **名前の示す内容**
3. 単語の選択

---

## 名前の示す内容

- 命名の対象が「何であるか・何をするか」を表現すること
- 「いつ・どこで・どのように使われるか」を言及しないこと

**対象の責任範囲と、対象を使っているコードが何をしているか**を明確にする

---

## 適切/不適切の例

適切な名前：何であるか・何をするかを表している

> `MessageListProvider`： メッセージのリストを提供するクラス
> `userId`： ユーザーの識別子
> `showErrorDialog`： エラーダイアログを表示する関数

不適切な名前：いつ・どこで・どのように使われるかを表している

> `onMessageReceived`： メッセージを受け取ったときに呼ばれる関数
> `isCalledFromEditScreen`： 編集画面から呼ばれたときに真になる値
> `idForNetworkQuery`： クエリーに使用される識別子<br>（ユーザーの識別子かもしれないし、クエリーの識別子かもしれない）

---

## 例1: 引数の名前

> 関数`showUserList`を定義する。ただしリスト取得に失敗した際
> - 起動直後の画面から呼び出した場合だとエラーダイアログを表示
> - それ以外だと何もしない

↓

```cpp
// ✕ 「誰に呼ばれたか」を示す仮引数
void showUserList(bool isCalledFromLandingScreen) { … }
```

---

## 例1: 引数の名前

> 関数`showUserList`を定義する。ただしリスト取得に失敗した際
> - 起動直後の画面から呼び出した場合だとエラーダイアログを表示
> - それ以外だと何もしない

｜　
｜ 「どういう時に何をするか」に注目して仮引数を命名する <!-- 失敗時にダイアログを表示する、が正しい。起動直後の画面から呼び出した場合に、ではない -->
↓

```cpp
// ◯「何をするか」を示す仮引数
void showUserList(bool shouldShowDialogOnError) { … }

// ✕ 「誰に呼ばれたか」を示す仮引数
void showUserList(bool isCalledFromLandingScreen) { … }
```

<!-- ◯とはいえ、引数で処理を変えるというのは、複数の制御が結合している制御結合になっているかもしれないことに注意。 -->

---

## 例2: 関数の名前

> メッセージを受け取ったときに動く、受信したメッセージ内容を画面に表示する関数に名前を付ける

↓

```cpp
// ✕ 「いつ呼ばれるか」を示す関数名
void onReceivedMessage(MessageModel model) { … }
```

---

## 例2: 関数の名前

> メッセージを受け取ったときに動く、受信したメッセージ内容を画面に表示する関数に名前を付ける

｜　
｜ 「何をするか」に注目して命名する <!-- 失敗時にダイアログを表示する、が正しい。起動直後の画面から呼び出した場合に、ではない -->
↓

```cpp
// ◯「何をするか」を示す関数名
void showReceivedMessage(MessageModel model) { … }

// ✕ 「いつ呼ばれるか」を示す関数名
void onReceivedMessage(MessageModel model) { … }
```
>>> ※ただし抽象メソッドとして機能提供する場合などは`onReceived～`も可。サブクラスでどう使われるか定義時点では分からないため。`

<!-- 一方でonReceivedMessageでも分かりやすいという気持ちも分かる。何のための処理かが分かるから。
でも、他の関数は「何をする」という意味で命名しているのにこちらは「いつ呼ばれる」と、方向性が異なっていることには留意してほしい。
 -->

<!-- もっと考えると、showReceivedMessageもなぜ呼ばれたかが意味に乗っているので
さらに「Received」を外してshowMessage(...)で良いかもしれない。ただしそこまで考えると今度は
汎用的になりすぎて使い方が分からないという話にもなるし、あるいはこの手のイベント受信で動くメソッドは
privateで定義されることが多いので、今のshowReceivedMessageで十分かもしれない。
ここでベストを決めるには情報が足りないので出来ないが、皆さんの環境ではこうした追加のコンテキストも含めて考えてほしい
 -->


---

## もちろん例外もある

宣言時点で「何をするか」が決まっていないもの

```cs
void sendHtmlRequest(HtmlRequest request, Result onFinished) { ... }
```



---

## 名前の示す内容: まとめ

- 命名の対象が「何であるか・何をするか」を表現すること
- 「いつ・どこで・どのように使われるか」を言及しないこと

**対象の責任範囲と、対象を使っているコードが何をしているか**を明確にする

---

## 命名

1. 命名に使う文法
2. 名前の示す内容
3. **単語の選択**

---

## 注意深く単語を選ぶ

- **曖昧性の少ない単語を選ぶ**
- 紛らわしい略語を避ける
- 単位や実体を示す語句を追加する
- 肯定的な単語を用いる

---

## 曖昧性の少ない単語を選ぶ

汎用的な名前を避け、より意味が限定された単語を使う。 `limit` < `min`,`max`

### ありがちな名前

- flag
- check
- old

---

## 曖昧な例①:flag「`bool initializationFlag`とは？」🤔

|状態|ふさわしい名前|
|---|---|
|初期化中|`isInitializing`|
|初期化済み|`wasInitialized`|
|初期化可能|`canInitialize`,`isInitializable`|
|初期化するべき|`shouldInitialize`, `isInitializationRequired`,<br>`requiresInitialization`|

フラグがtrueのときに何を示しているかに着目する

---

## 曖昧な例②:check「`checkMessage()`とは？」🤔

|行為|ふさわしい名前|
|---|---|
|条件に合致するかを返す|`hasNewMessage`, `isMessageFormatValid`,<br>`throwIfMessageIdEmpty`|
|条件に合うものを返す|`takeSentMessage`, `takeMessagesIfNotEmpty`|
|外部から取得する|`queryNewMessages`, `fetchQueuedMessageList`|
|内部状態を更新・同期する|`updateStoredMessages`, `syncMessageListWithServer`|

呼び出しで状態変化を伴う→変更内容に着目 / 伴わない→戻り値や例外の内容に着目

---

## 曖昧な例③:old「`oldIdentifier`とは？」🤔

|状態|ふさわしい名前|
|---|---|
|1つ前の状態|`previous〜`|
|無効化された値|`invalidated〜`, `expired〜`|
|変更前の値|`original〜`, `unedited〜`|
|既に取得・保存した値|`fetched〜`, `cached〜`, `stored〜`|
|(非推奨のクラスなど)|`deprecated`|

比較対象の有無・条件を満たしているかどうかに着目。oldが範囲を示す場合は`before`/`until`/`by`も候補になる


---

## より曖昧さの少ない単語を探すには

（業務ドメインを意識しつつ）辞書や類語辞典を利用する。それでもうまく見つけられない場合、同じ単語を使う別の状況を想定して比較するのも良い。

#### 例：値を取得する関数名で`get〜`しか思いつかない…

- データのソース：既に持っている値を返すか・計算で取得するか・NWを使うか
- 状態の変更を伴うか：何も変更しないか・キャッシュするか・元データを削除するか

→ `find`,`search`,`pop`,`calculate`,`fetch`,`query`,`load`などを連想できる
→ set～も`cache`,`update`,`configure`,`initialize`,`register`,`apply`,`store`が候補に

<!--
set系だと
assign: 既存の値を新しい値に置き換える場合。
update: 既存のデータを変更する場合。
configure: 設定や構成を行う場合。
initialize: 初期値を設定する場合。
insert: 新しいデータを追加する場合。
append: 既存のデータに新しいデータを追加する場合。
register: システムやリストに新しいエントリを追加する場合。
apply: 特定の設定や変更を適用する場合。
load: データを読み込んで設定する場合。
store: データを保存する場合
 -->
<!-- ただし語彙力も重要。若かりし日の過ちを打ち明けると、「工場出荷リセットしてもずっと保持し続ける情報の格納庫」に
EternalDataStoreと名付けてしまった。永久の/無限にはちょっと意味が大きすぎる。PersistentDataStore,FactoryResetSafeDataStoreにしておくべきだった。 -->
<!-- 今はChatGPTやCoPilotがあるから、仕様を説明して考えてもらうのも良い -->

---

## 注意深く単語を選ぶ

- 曖昧性の少ない単語を選ぶ
- **紛らわしい略語を避ける**
- 単位や実体を示す語句を追加する
- 肯定的な単語を用いる

---

## 紛らわしい略語を避ける

大きなルールは２つ

1. 一般知識・プロダクト用語・言語・使用プラットフォーム以外の省略語は<br>原則使わない
    - `im`＝`illegalMessage`?`inputMethod`?`instanceManager`??
2. デファクトスタンダードな省略語は、狭いスコープでのみ使って<br>よいこともある
    - 文字列を`str`, ミリ秒を`millis`(Javaのみ)

<!-- Javaの標準APIに ClockInMillis, System#currentTimeInMillis などがあるのでデファクトとしての標準的な省略語。
でも他の言語では聞かないので使わないほうがよい。InMilliSeconds、InMsなど言語の例を見るとよい。
また言語として標準の単位があるのでそれに従うべき（JSだとミリ秒、Pythonだと秒） -->

---

## 単位や実体を示す語句を追加する - 1

時間、長さ、通貨、2次元配列のループにおける列と行などを区別できるようにする。

- `timeout` → `timeoutInMillis`/`timeoutInSeconds` $^{※1}$
- `pixels`,`points`,`inches`
- `i, j` → `row, col`

ドメイン駆動開発の値オブジェクトのように、単位を型で表す方法も考慮できる。

```cpp
class Inch { int value; }
class Centimeter { int value; }
void setWidth(Inch width) { ... } // SetWidth(Centimeter(10))はコンパイルエラー
```

>>> 1: 単位の前に`In`をつけると英文法として自然。ただし言語環境やフレームワークによっては省略されることもある

---

## 単位や実体を示す語句を追加する - 2

単位だけでなく別種の値を同じ情報(型)として示す場合も同様

**例**: 背景色の指定にARGB,HSLを使う、または色を定義したリソースのIDを使う

- backgroundArgbColor
- backgroundHslColor
- backgroundColorId

※ ただしこの場合も名前が正しい文法に沿っているかに注意する

---

## 肯定的な単語を用いる

`isEnabled` > `isDisabled`。`!isDisabled`と書いたときに二重否定になって迷う。

```cpp
if (!window.isNotDisabled) { // 🤔 (5分後)…isEnabledでいいんじゃない？
    ...
}
```

一応例外もあるが(↓)、使わないにこしたことはない。

- ほとんどの状況で否定演算子と共に使う場合
- disabledな状態が特殊な意味を持つとき

---

## 「郷に入っては郷に従え」も大事

- プロジェクトのコーディングガイドラインが第一
- 異なるネーミングルールの混在は混乱の元にしかならない
    - 名前だけでなく技術も同様。
- 悪法もまた法なり$^1$

許せない場合は(少しずつ)変えていくチャンスと捉えよう<br>(ボーイスカウトルール)

>>> 俗にソクラテス(古代ギリシャの哲学者)が死刑判決を下された時に言ったといわれている。

---

## 命名のまとめ

- **文法**
    - 名詞句: もっとも重要な単語を名前の最後に置く
    - 命令形: 動詞の原形を名前の最初に置く
- **名前の示す内容**
    - 表現すべきもの: 対象が何であるか・何をするか
    - 表現すべきでないもの: いつ・誰が・どのように使うか
- **単語の選択**
    - 曖昧性が少ない単語を選ぶ
    - 紛らわしい省略語を避ける
    - なるべく肯定的な単語を用いる
    - 型や単位を付記する

<!--
言語の本質は心理的な相互作用。音声でも文字でもない
これはエドワード・サピアというアメリカの人類学者・言語学者が言っていることの解釈。
言語学は話し言葉にあるとしつつも、心理学も重要だと説いている

- 言語って話し言葉から生まれている。そりゃそうだ。
- 話し言葉や音声もあくまで口という本来食べるための器官に音を出させているもの
    - 人間/生物って音声器官を持っていない。ピアノを弾く指が演奏器官と言わないのと同じ(レトリックに偏っているが)
- 文字や書き言葉は話し言語を書き下したもの
- つまり言語とは、文字や音を相互に交換することによる、お互いあるいは集団の心理的な相互作用

順番を心理面から並べて言うと、言語とは心理ではあるが、それを口という器官に目的外のことをさせて音に変換・記号化して、それを耳で聞いたものを文字や書き言葉に記号化している。書き言葉って二次創作物。
そしてそれを私たちはプログラムコードの中で使っている。

この状況において、曖昧適当な命名をしてしまうと、心理という一番伝えたいものの記号の記号（二次創作）を
めちゃくちゃにしてしまうので、命名ってすごく大事。
 -->