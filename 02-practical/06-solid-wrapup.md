---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

# SOLIDまとめ

---

## SOLIDの５原則

* S: 単一責任の原則: Sindle Responsibility Principle(SRP)
* O: 開放閉鎖の原則: Open/Closed Principle(OCP)
* L: リスコフの置換原則: Liskov Substitution Principle(LSP)
* I: インターフェース分離の原則: Interface Segregation Principle(ISP)
* D: 依存関係逆転の原則: Dependency Inversion Principle(DIP)

<!-- これらを実践することで堅牢なアーキテクチャを持つソフトウェアができる。 -->
<!-- 他の原則が割と覚えてからしばらく経つと使いこなせるようになるものが多いのに対して、この原則はすぐに設計や実装に使えるのが特徴 -->

---

## 各原則の振り返り

---

## 各原則の関係

![contain center](assets/06-relationship.png)

---

<!-- 悪いコードは臭いがします。その臭いがする箇所を残したままにしておくことは、
将来に渡って悪影響を及ぼします。箱の中の腐ったみかんは周囲のコードまで汚染していきますし、
割れ窓理論のように一部の悪い環境は悪習慣を生み出します。臭いは早めに消臭しないといけません。 -->

<!-- 私も書いた本「iOSアプリ設計パターン入門」では主要な臭いをいくつかに分類しています。
それらに対してSOLIDはどのように適用できるかを示したのがこのスライドです -->

* **硬さ**: 設計変更が困難
    * ← **OCP, ISP, DIP**
* **もろさ**: ある変更が他の箇所に影響を与える。設計が壊れやすい
    * ← **OCP, ISP, DIP**
* **移植性のなさ**: 設計の再利用が困難
    * ← **OCP, DIP**
* **扱いにくさ**: 正しい設計をするのが困難
* **不必要な複雑さ**: 行き過ぎた設計。「あとで必要になるかも」
    * ← **SRP, ISP**
* **不必要な繰り返し**: 似たようなコードがいたるところに
    * ← **SRP, ISP**
* **不透明さ**: 整然としない表現
    * ← **SRP, OCP, ISP**

---

## まとめ

* SOLIDはオブジェクト指向で設計する際に重要な設計原則
    * 保守性を高め、変更にも強い構造にできる
* オブジェクト指向でなくても役に立つ部分は多い


<!-- 個人的な意見だが、SOLID以前と以後という区別も出来るくらいに重要 -->
