---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

<!-- 会社のコンプライアンスを逸脱しないよう、ハラスメントをしないよう働くためには、何をしたらいいと思いますか？

答は「リスコフの置換原則を守ればいい」です。 -->

---

# SOLID #3 リスコフの置換原則
_Liskov Substitution Principle_

> ### 型$S$の各オブジェクト$o_{1}$に対し、型$T$のオブジェクト$o_{2}$が存在し、$T$に関して定義されたすべてのプログラム$P$が$o1$を$o2$で置き換えても動作を変えない場合、$S$は$T$のサブタイプである。$^1$

>>> 1:1987年10月のOOPSLAでのバーバラ・リスコフの基調講演 “Data abstraction and hierarchy” にて提唱

<!-- 今回はLSP。SOLIDというオブジェクト指向で設計するときに常に手元においておきたい５大原則のうち、親クラスと子クラスがどういう関係にあれば継承のメリットを最大限活かせるかを示した原則。 -->

<!-- バーバラ・リスコフ（Barbara Liskov、1939年11月7日-）はアメリカ合衆国の計算機科学者。MITの電気工学/計算機科学部門の教授を務めている。女性。 -->
<!-- 1968年、スタンフォード大学でアメリカ合衆国で女性として初の計算機科学の博士号を取得した。さらに計算機科学における最高賞であるチューリング賞を受賞した2人目の女性 -->

---

## リスコフの置換原則とは

> 型$S$の各オブジェクト$o_{1}$に対し、型$T$のオブジェクト$o_{2}$が存在し、$T$に関して定義されたすべてのプログラム$P$が$o1$を$o2$で置き換えても動作を変えない場合、$S$は$T$のサブタイプである。
>
> _Barbara Liskov_

![bg right 70%](assets/03-lsp-portlait_liscov.jpg)

>>> https://ja.wikipedia.org/wiki/バーバラ・リスコフ

---

## 以下を守れればOK

1. 事前条件を派生型で強めることはできない。派生型では同じか弱められる
2. 事後条件を派生型で弱めることはできない。派生型では同じか強められる
3. 不変条件は派生型でも保護されねばならない。派生型でそのまま維持される
4. 基底型の例外から派生した例外を除き、派生型で独自の例外を投げてはならない

<!--
* 事前条件: 呼び出し側が守らなければならない条件
* 事後条件: 呼ばれる側が守らなければならない条件
* 不変条件: 呼び出し前、呼び出し後で維持されなければならない性質
「契約による設計」より
-->

---

![bg](assets/03-lsp-spacecat.jpg)

>>> https://twitter.com/satuki_0501/status/1462725522924847104

---

## LSPの言っていることは簡単

派生クラスが親クラスの定めたルールを逸脱してはならない

* 親クラスで規定していないことをやろうとしている

> → 使用側が特定の派生クラスに限定した処理を呼ばなければならなくなる

![bg right contain](assets/03-lsp-invalid.png)

<!-- * 親クラスにない公開メソッドを派生クラスで勝手に追加する
* 親クラスよりも厳しい引数チェックをする
* 親クラスよりも出力値の範囲が広い -->

<!-- 使用側にバッドノウハウが溜まっていってしまう -->

---

## もう一度ルールを見てみる

1. 事前条件を派生型で強めることはできない。派生型では同じか弱められる
2. 事後条件を派生型で弱めることはできない。派生型では同じか強められる
3. 不変条件は派生型でも保護されねばならない。派生型でそのまま維持される
4. 基底型の例外から派生した例外を除き、派生型で独自の例外を投げてはならない

<!--
* 事前条件: 呼び出し側が守らなければならない条件
* 事後条件: 呼ばれる側が守らなければならない条件
* 不変条件: 呼び出し前、呼び出し後で維持されなければならない性質
「契約による設計」より
-->

<!--
* パソコンをメーカーごとに使い分ける例：
    * エプソンは閉じるボタンが右上
    * マウスは最大化をしてからPCを斜め45度の角度でチョップ
* デバイスドライバーやライブラリとして「こう使えばOK」と言っているのに、実装している人が勝手に逸脱した判定条件とか付けてたら
* プログラムを書かない人も、仕様書やマニュアルというインターフェイス(親クラス)に対して実装が違っているものを自分が作っているとして、そういうシステム、そういうドキュメントが使いやすいかを考える
    * コードの中の親子関係でなく、仕様とコードを親子関係とみなせば、LSPの適用範囲もかなり広いことが分かる。継承で書くことが少ない・書かない場合でも当てはまるよ。
-->

---

## LSPはどう使う？
 
* **設計時**：ポリモーフィズムでダウンキャストしない / 派生クラスでしか使えないメソッドを用意しない
* **違反の臭い**：使用する側が派生クラスの型を知っている。派生クラスが親クラスの挙動を変更している
* **消臭方法**：ダウンキャストして呼んでいるメソッドなどを親クラスに移す。あるいは別の処理が混じっていると考えクラス構成を変える。継承が必要なのか考え直す
 
 <!--
 冒頭でコンプライアンスを守って働くにはどうしたら良いかという問いをしました。そして、リスコフの置換原則とは
 親クラスが定めたルールを派生クラスが逸脱しないようにすることだと言いました。

 外部の人間から見れば私達は「〇〇会社の代表」として見られています。その状態で暴れん坊なことをしてしまうと
 色々と問題がありますよね。会社の定めたルールで働いています。それを守るということで会社員としての私達も
 存続できているわけです。つまりこれがコンプライアンスを守っていくためにはリスコフの置換原則を守るという話のタネです。
 
 なんとも含蓄のある原則ですね。
 言い換えると、リスコフの置換原則に違反すると訓戒事例にて晒されるので注意してください。
 -->

---

## 補講: 契約による設計$^1$(Design by Contract。DbC)

ある処理を呼ぶ側と呼ばれる側とで守るべき条件を定める、ソフトウェアの正確性と頑健性を高めるための設計の方法論

* 事前条件: 呼び出し側が処理を呼ぶ時に守らなければならない条件
* 事後条件: 呼ばれた側が処理終了までに守らなければならない条件
* 不変条件: 呼び出し前、呼び出し後で維持されなければならない性質

>>> 1: バートランド・メイヤーの1990年の論文及び著書『Object-Oriented Software Construction』で提唱

<!-- 呼ぶ側も呼ばれる側も、あらかじめ定めた契約を守っていればちゃんと動く安全なプログラムを構築できるという考え方。 -->
<!-- Eiffel(エッフェル), Ada(エイダ),Kotlin, Clojureなど、言語としてDbCをサポートしているものもある。
C++でもBoostライブラリでBoost.Contract(https://www.boost.org/doc/libs/master/libs/contract/doc/html/index.html)がある。
Pythonにもいくつかライブラリがあるし、PEP 316で提案された…がdeferred扱いになっている -->

<!-- 日本では『オブジェクト指向入門』としてアスキー出版局から1990年に出ていて、第２版も2007年に日本語版が出ている。２巻構成で、全1600ページの、ゲームで言えば中盤に出てくる両手持ち武器くらいの鈍器 -->

