---
marp: true
theme: katas
---
<!--
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

# 参照の一点性

_Single point of reference_

>>> 注:「定義の一点性(_Single Point of Definition_)」「単一代入」とも言う。

<!-- 初出は書籍「ソフトウェアアーキテクチャ ― ソフトウェア開発のためのパターン体系」F.ブッシュマン他, 近代科学社(2000)の
アーキテクチャ根底技法として１０点紹介されたものの１つ。よりよいモジュールの設計方針として紹介されたこの技法の中には分割と統治も含まれている。

モジュールといってもライブラリやパッケージのような大きな単位だけでなく、クラスや関数・データの集まりに対しても適用できるもので、
開発方法論やプログラミング言語の種類とは関係なく利用できるものなので覚えて行ってほしい -->
---

## 参照の一点性$^1$

変数を一度定義したら値を書き換えない。

```py
x = 193
 :
x = 4649 # NG.値を途中で書き換えない
 :
```
↓
```py
x = 193
 : # xは通用範囲(スコープ)内で常に193
y = 4649 # 別の値には別の変数を用意する
 :
```

⇒ 値が変化することを考えなくて済む、見通しの良いコードになる。

---

## メリット：副作用がなくなる

**副作用とは**： 処理の呼び出しによってモジュールやクラスの状態が変化すること。呼ぶ前と呼んだ後とで得られる結果が変化する(かもしれない)

* 副作用のある処理がたくさんあると何が起きるか
    * 起動してからしばらくすると処理がおかしくなる
        * 途中でグローバル変数の値を書き換えていた
    * 処理結果がときどきおかしな計算結果を返す
        * 結果を参照する前に別タスクで処理が走っていた

→ **変数に値を再代入しないようにする**

<!-- 少し遠いところの話になるけれど、並行処理(マルチタスク/マルチスレッド)で安全なプログラムが書けるようになる -->

---

## おとしどころ…

…とはいえ、真面目に単一代入だけで作ろうとするのは関数型プログラミングの技法が必要になるなど大変。ループも再帰で書かないといけなくなる。

```py
# nの階乗をループで書く
def f(n):
  x = 1
  for i in range(n):
    x *= (i+1)
  return x
```
```py
# nの階乗を単一代入で書く
def factorial(n):
　if n < 2:
    return 1
　return n * factorial(n - 1)
```

<!-- ちなみに再帰は２－３種類のパターンがあるだけなので、それさえ覚えてしまえば意外と頭に入ってきます。及び腰になっている人もこの記事とかで読んでおくと良いです。
https://speakerdeck.com/kishida/write-a-executable-process-for-ai-era
-->

---
## 目安

### 変数の定義で単一代入を扱うようにする

* 関数の引数は変更しない
* ループは別腹

### 再代入を行う処理と行わない処理とを分離する

* 再代入を行うmutableな処理と行わないimmutableな処理とを分けて書くと良い
    * 問題が起きたときはmutableの処理から調べれば良くなる

<!-- Webから入ってきた、厳密にはドメイン駆動設計で言葉が定義された「リポジトリパターン」のように、情報を特定の場所にまとめておいて
他の場所ではその操作のみ書くというのも。WPFやWinUIで使われることの多いMVVMパターンもそう。
画面表示に必要なデータ(ViewModel)を画面表示処理(View)そのものとは切り離しておくことで、画面表示を参照透過に作るパターンといえる。
さらに拡張させると、ViewModelすらもModelと連携させるMVというパターンもある。これはSwiftUI界隈。
-->
<!-- 言葉として定義と代入とを分けて考えると良いかも。 -->

---

## (参考)参照透過性を持つ関数

２つの特性を持つ関数のこと

1. 呼び出しの結果が、引数のみに依存する
    * 処理が冪(べき)等であり、何回呼んでも同じ結果を返す
    * 内部で他のメンバー変数などの状態を参照していない
2. 呼び出しが、他機能の動作に影響を与えない
    * 関数が副作用を持っていない

テストが非常に楽になり、再利用性も高まる。

<!--
Q&A: 中で状態を持たないクラスや関数を扱う場合、引数が大量になる場合はどうしたらいい？
→ それぞれがまったく別の情報であれば、大量になっていても別に構わない。ただ、同じカテゴリーの情報があるとすれば、
グルーピングしたクラスや構造体にまとめてから渡すとよい。例えば２次元平面上の２つの点を渡すと距離が得られる関数があったとして、
その関数の引数に x1,y1,x2,y2 と渡すか、あるいはPoint型みたいなものを作って p1, p2 と渡すかどちらが分かりやすいかという話になる。
一方で後者のp1,p2だと、関数を呼ぶときに毎回Point型に変換しなければならない手間を感じるかもだが、言っても1-2行増えるだけだし、
意味は強化されるので問題なしと考えた方が保守性がよい。
-->