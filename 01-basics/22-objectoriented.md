---
marp: true
math: mathjax
theme: katas
---
<!-- 
size: 16:9
paginate: true
-->
<!-- header: 勉強会# ― エンジニアとしての解像度を高めるための勉強会-->

# もう一度学ぶオブジェクト指向

_抽象を意識したプログラミングの実践技法_

---

## タネ本
### 『ちょうぜつソフトウェア設計入門<br>　―― PHPで理解するオブジェクト<br>　 指向の活用』

- 田中ひさてる(著)
- 技術評論社 2022/12/22 初版

![bg right:40% 90%](assets/22-oo_bookcover.jpg)

---

## 「オブジェクト指向」ってなんだと思いますか？

「オブジェクト指向」と聞いたときに何を思い浮かべるでしょうか？

* クラスを使った型を大事にしたプログラミング？
* 状態変化の管理単位？
* 昔から何か言われているバズワード？

---

## オブジェクト指向の定義はない

世の中でも明確な定義はないまま「なんとなくこれがオブジェクト指向だろう」で扱っている状態

* ❌️ オブジェクトは現実を再現する
* ❌️ プログラミング言語の文法である
* ❌️ 状態管理をするものである
* ❌️ 手続き型プログラミングである

厳密な意味を求めようとせず、ソフトウェア開発に便利な考え方(の１つ)として捉えるようにする

<!-- あえて言うなら…「ものが物体として存在するイメージでプログラミングをうまくやろう」 -->

---

## オブジェクト指向のメリット

1. カプセル化
1. 多態性(ポリモーフィズム)
1. 継承/汎化

---

## 1.カプセル化

カプセル化＝「グルーピング」と「情報隠蔽」

### グルーピング
* 関係の強いものを１つの概念単位(クラス, パッケージ, etc.)にまとめる
* 適切にグルーピングできている → **凝集度が高い**

### 情報隠蔽
* 他に見せなくて良いものは隠す
* 知識最小の原則

---

## 問題

なぜカプセル化が大事と言われるのでしょうか？

---

## 問題

なぜカプセル化が大事と言われるのでしょうか？

### 答： 関心の分離(Separation of Concerns, SoC)を実現できるため

> * 関心の分離： 異なる機能・役割を持つものを分類する設計原則
> 凝集性を高め、保守性を上げられる

---

## 2.多態性(ポリモーフィズム)

乱暴に言ってプラグインを実現する仕組み。

* 仕様に準拠していれば、中身を変えても同じように使える
* 使う側のロジックをシンプルにできる  

```cpp
struct Runnable { virtual void run() = 0; };
struct Car: public Runnable { void run() {...} };
struct Dog: public Runnable { void run() {...} };

Runnable *a = new Car();
a->run(); // Carのrun()が呼ばれる
delete a;
a = new Dog();
a->run();  // Dogのrun()が呼ばれる
```

---

## 多態性とクラスや親子関係の有無は別問題

呼び出し側が「同じと認識してよい」と見立てたものに対して、複数種類の実体がある点に着目した概念

* JavaScriptやPythonのように型チェックしない書き方ができる言語
    * 同じ名前のメソッドがあれば問題なく呼び出せる（ダックタイピング）
* C++においては「型」が見立ての基準になっているだけ

```js
// JavaScriptの例。dogとcatに継承関係はない
dog = {"howl": ()=>{console.log("bow")}};
cat = {"howl": ()=>{console.log("meow")}};
pet = dog; // catも代入できる
pet.howl(); // bow or meow
```
---

## 3.継承/汎化

他のオブジェクトの特性を引き継ぐこと

```cpp
struct Base {
    virtual ~Base() {}
    int state = 193;
    void methodA() {}
    virtual void methodB() {} // 派生クラスでの上書きを許可
};
struct Derived: public Base {
    virtual ~Derived() {}
    void methodB() override { std::cout<<state; } // 親クラスの処理を上書き
    void methodC() {} // 新しいメソッドを定義
};

Base *obj = new Derived();
obj->methodB(); // → 193
```

---

## 抽象クラス / インターフェース

```cpp
// 抽象クラス。実処理が(一部)書かれている。
struct AbstractBase {
    virtual ~AbstractBase() {} // 仮想デストラクタ
    int state = 193;
    void methodA() {...} // 実処理を持つ
    virtual void methodB() = 0; // 実処理を持たない
};

// インターフェースクラス。一切の実装を持たない
struct SomeInterface {
    virtual ~SomeInterface(){} // 仮想デストラクタ
    virtual void methodA() = 0;
    virtual void methodB() = 0;
}
```

---

## 問題

継承の目的は何？

---

## 問題

継承の目的は何？

1. **特化・汎化をするため**
2. **差分プログラミング・サブタイピングをするため**

---

## 特化と汎化

クラスの持つ特性を元に具体化(=特化)すること・抽象化(=汎化)すること

### 特化(Specialization)
* 親クラスの処理をより具体化したり、特定ドメインにフォーカスすること
* 親クラスから見れば、子クラスはすべて特化したもの<br>(になるはず)

### 汎化(Generalization)
* いくつかのクラスが持つ特性を包括的/汎用的にした上位抽象
* 子クラスから見れば、親クラスは自分/兄弟クラスの内容を汎化したもの<br>(になるはず)

---
## 差分プログラミング・サブタイピング

### 差分プログラミング

### サブタイピング